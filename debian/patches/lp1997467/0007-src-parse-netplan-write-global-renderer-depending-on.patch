From: =?utf-8?q?Lukas_M=C3=A4rdian?= <slyon@ubuntu.com>
Date: Thu, 8 Dec 2022 18:14:37 +0100
Subject: src:parse:netplan: write global renderer depending on output file

When parsing the global renderer, we also want to store the path+filename of
the parsed value in a new ->global_renderer datastructure (in parser & state).
This way, when generating YAML output, we can put a different/new renderer
stanza (e.g. from "netplan set network.renderer=...") into a higher order YAML
file while conserving the renderer data in the original YAML files.

The renderer can be parsed from an existing file or a new, unnamed YAML patch.
If the path is known, we want to write back the data to that file only. If the
path is unknown/anonymous (i.e. emtpy string) we want to write that data to the
fallback file (e.g. 70-netplan-set.yaml or <origin-hint>.yaml).
---
 src/netplan.c             | 41 ++++++++++++++++++++++++++++++-----------
 src/parse.c               | 26 +++++++++++++++++++++++++-
 src/types.c               |  5 +++++
 src/types.h               |  2 ++
 tests/test_cli_get_set.py | 43 ++++++++++++++++++++++++++++++++++++-------
 5 files changed, 98 insertions(+), 19 deletions(-)

diff --git a/src/netplan.c b/src/netplan.c
index 2fe56d6..4596e30 100644
--- a/src/netplan.c
+++ b/src/netplan.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2021 Canonical, Ltd.
+ * Copyright (C) 2021-2023 Canonical, Ltd.
  * Author: Lukas MÃ¤rdian <slyon@ubuntu.com>
  *
  * This program is free software; you can redistribute it and/or modify
@@ -991,7 +991,7 @@ contains_netdef_type(gconstpointer value, gconstpointer user_data)
 }
 
 static gboolean
-netplan_netdef_list_write_yaml(const NetplanState* np_state, GList* netdefs, int out_fd, GError** error)
+netplan_netdef_list_write_yaml(const NetplanState* np_state, GList* netdefs, int out_fd, const char* out_fname, gboolean is_fallback, GError** error)
 {
     GHashTable *ovs_ports = NULL;
 
@@ -1015,11 +1015,27 @@ netplan_netdef_list_write_yaml(const NetplanState* np_state, GList* netdefs, int
     /* We support version 2 only, currently */
     YAML_NONNULL_STRING_PLAIN(event, emitter, "version", "2");
 
-    if (netplan_state_get_backend(np_state) == NETPLAN_BACKEND_NM) {
-        YAML_NONNULL_STRING_PLAIN(event, emitter, "renderer", "NetworkManager");
-    } else if (netplan_state_get_backend(np_state) == NETPLAN_BACKEND_NETWORKD) {
-        YAML_NONNULL_STRING_PLAIN(event, emitter, "renderer", "networkd");
+    /* fallback to default global handling, if renderer was not set for this file */
+    NetplanBackend renderer = netplan_state_get_backend(np_state);
+    /* Try to find a file specific (global) renderer.
+     * If this is the fallback file (70-netplan-set.yaml or <origin-hint>.yaml),
+     * a renderer parsed from a YAML patch takes precedence. */
+    if (out_fname && np_state->global_renderer) {
+        gpointer value;
+        renderer = GPOINTER_TO_INT(g_hash_table_lookup(np_state->global_renderer, out_fname));
+        /* A renderer parsed from an (anonymous) YAML patch takes precendence
+         * (e.g. "netplan set ..."). Such data does not have any filename
+         * associated to it in the global_renderer map (i.e. empty string). */
+        if (is_fallback && g_hash_table_lookup_extended(np_state->global_renderer, "", NULL, &value))
+            renderer = GPOINTER_TO_INT(value);
     }
+    if (renderer == NETPLAN_BACKEND_NM || renderer == NETPLAN_BACKEND_NETWORKD)
+        YAML_NONNULL_STRING_PLAIN(event, emitter, "renderer", netplan_backend_name(renderer));
+
+    /* Do not write any netdefs, if we're just setting/updating some globals,
+     * e.g.: netplan set "network.renderer=NetworkManager" */
+    if (!netdefs)
+        goto skip_netdefs;
 
     /* Go through the netdefs type-by-type */
     for (unsigned i = 0; i < NETPLAN_DEF_TYPE_MAX_; ++i) {
@@ -1053,6 +1069,7 @@ netplan_netdef_list_write_yaml(const NetplanState* np_state, GList* netdefs, int
         }
     }
 
+skip_netdefs:
     write_openvswitch(event, emitter, &np_state->ovs_settings, NETPLAN_BACKEND_NONE, ovs_ports);
 
     /* Close remaining mappings */
@@ -1082,7 +1099,7 @@ file_error:
  * relevant.
  *
  * @np_state: the state for which to generate the config
- * @filename: Relevant file basename
+ * @filename: Relevant file basename (e.g. origin-hint.yaml)
  * @rootdir: If not %NULL, generate configuration in this root directory
  *           (useful for testing).
  */
@@ -1106,7 +1123,8 @@ netplan_state_write_yaml_file(const NetplanState* np_state, const char* filename
     }
 
     /* Remove any existing file if there is no data to write */
-    if (to_write == NULL) {
+    gboolean write_globals = !!np_state->global_renderer;
+    if (to_write == NULL && !write_globals) {
         if (unlink(path) && errno != ENOENT) {
             g_set_error(error, G_FILE_ERROR, errno, "%s", strerror(errno));
             return FALSE;
@@ -1121,7 +1139,7 @@ netplan_state_write_yaml_file(const NetplanState* np_state, const char* filename
         return FALSE;
     }
 
-    gboolean ret = netplan_netdef_list_write_yaml(np_state, to_write, out_fd, error);
+    gboolean ret = netplan_netdef_list_write_yaml(np_state, to_write, out_fd, path, TRUE, error);
     g_list_free(to_write);
     close(out_fd);
     if (ret) {
@@ -1146,7 +1164,7 @@ netplan_state_dump_yaml(const NetplanState* np_state, int out_fd, GError** error
     if (!np_state->netdefs_ordered && !netplan_state_has_nondefault_globals(np_state))
         return TRUE;
 
-    return netplan_netdef_list_write_yaml(np_state, np_state->netdefs_ordered, out_fd, error);
+    return netplan_netdef_list_write_yaml(np_state, np_state->netdefs_ordered, out_fd, NULL, TRUE, error);
 }
 
 /**
@@ -1195,11 +1213,12 @@ netplan_state_update_yaml_hierarchy(const NetplanState* np_state, const char* de
     g_hash_table_iter_init(&hash_iter, perfile_netdefs);
     while (g_hash_table_iter_next (&hash_iter, &key, &value)) {
         const char *filename = key;
+        gboolean is_fallback = (g_strcmp0(filename, default_path) == 0);
         GList* netdefs = value;
         out_fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0640);
         if (out_fd < 0)
             goto file_error;
-        if (!netplan_netdef_list_write_yaml(np_state, netdefs, out_fd, error))
+        if (!netplan_netdef_list_write_yaml(np_state, netdefs, out_fd, filename, is_fallback, error))
             goto cleanup; // LCOV_EXCL_LINE
         close(out_fd);
     }
diff --git a/src/parse.c b/src/parse.c
index efd7d12..a66b018 100644
--- a/src/parse.c
+++ b/src/parse.c
@@ -2789,7 +2789,15 @@ handle_network_version(NetplanParser* npp, yaml_node_t* node, const void* _, GEr
 static gboolean
 handle_network_renderer(NetplanParser* npp, yaml_node_t* node, const void* _, GError** error)
 {
-    return parse_renderer(npp, node, &npp->global_backend, error);
+    gboolean res = parse_renderer(npp, node, &npp->global_backend, error);
+    if (!npp->global_renderer)
+        npp->global_renderer = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL);
+    char* key = npp->current.filepath ? g_strdup(npp->current.filepath) : g_strdup("");
+    /* Track the global renderer value of the current file.
+     * If current.filepath is empty, this YAML is parsed from an unnamed YAML
+     * patch (e.g. via 'netplan set <SOME_PATCH>'). */
+    g_hash_table_insert(npp->global_renderer, key, GINT_TO_POINTER(npp->global_backend));
+    return res;
 }
 
 static gboolean
@@ -3241,6 +3249,12 @@ netplan_state_import_parser_results(NetplanState* np_state, NetplanParser* npp,
         g_hash_table_foreach_steal(npp->sources, insert_kv_into_hash, np_state->sources);
     }
 
+    if (npp->global_renderer) {
+        if (!np_state->global_renderer)
+            np_state->global_renderer = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL);
+        g_hash_table_foreach_steal(npp->global_renderer, insert_kv_into_hash, np_state->global_renderer);
+    }
+
     /* We need to reset those fields manually as we transfered ownership of the underlying
        data to out. If we don't do this, netplan_clear_parser will deallocate data
        that we don't own anymore. */
@@ -3327,6 +3341,11 @@ netplan_parser_reset(NetplanParser* npp)
         g_hash_table_destroy(npp->sources);
         npp->sources = NULL;
     }
+
+    if (npp->global_renderer) {
+        g_hash_table_destroy(npp->global_renderer);
+        npp->global_renderer = NULL;
+    }
 }
 
 void
@@ -3350,6 +3369,10 @@ is_netdef_id_or_global_value(const char* full_key)
     gchar** split = g_strsplit(key, "\t", 0);
     if (split[0] && g_strcmp0(split[0], "network") == 0) {
         if (split[1]) {
+            if (g_strcmp0(split[1], "renderer") == 0) {
+                ret = TRUE; // a valid global keyword
+                goto cleanup;
+            }
             /* check if is valid network type */
             for (unsigned i = 0; i < NETPLAN_DEF_TYPE_MAX_; ++i) {
                 const char* def_type_name = netplan_def_type_name(i);
@@ -3364,6 +3387,7 @@ is_netdef_id_or_global_value(const char* full_key)
             }
         }
     }
+cleanup:
     g_strfreev(split);
     return ret;
 }
diff --git a/src/types.c b/src/types.c
index 5982a39..fec3b13 100644
--- a/src/types.c
+++ b/src/types.c
@@ -430,6 +430,11 @@ netplan_state_reset(NetplanState* np_state)
         g_hash_table_destroy(np_state->sources);
         np_state->sources = NULL;
     }
+
+    if (np_state->global_renderer) {
+        g_hash_table_destroy(np_state->global_renderer);
+        np_state->global_renderer = NULL;
+    }
 }
 
 NetplanBackend
diff --git a/src/types.h b/src/types.h
index bd6c25b..b00ea00 100644
--- a/src/types.h
+++ b/src/types.h
@@ -182,6 +182,7 @@ struct netplan_state {
     /* Hashset of the source files used to create this state. Owns its data (glib-allocated
      * char*) and is initialized with g_hash_table_new_full to avoid leaks. */
     GHashTable* sources;
+    GHashTable* global_renderer;
 };
 
 struct netplan_parser {
@@ -241,6 +242,7 @@ struct netplan_parser {
     /* Which fields have been nullified by a subsequent patch? */
     GHashTable* null_fields;
     GHashTable* null_overrides;
+    GHashTable* global_renderer;
 };
 
 #define NETPLAN_ADVERTISED_RECEIVE_WINDOW_UNSPEC 0
diff --git a/tests/test_cli_get_set.py b/tests/test_cli_get_set.py
index 3f32e93..4d1af8c 100644
--- a/tests/test_cli_get_set.py
+++ b/tests/test_cli_get_set.py
@@ -118,12 +118,18 @@ class TestSet(unittest.TestCase):
         defaults = os.path.join(self.workdir.name, 'etc', 'netplan', '0-snapd-defaults.yaml')
         with open(defaults, 'w') as f:
             f.write('''network:
-  renderer: NetworkManager
+  renderer: networkd
   bridges: {br54: {dhcp4: true, dhcp6: true}}
   ethernets: {eth0: {dhcp4: true}}''')
+        self._set(['network.version=2', '--origin-hint=90-snapd-config'])
+        self._set(['renderer=NetworkManager', '--origin-hint=90-snapd-config'])
         self._set(['bridges.br55.dhcp4=false', '--origin-hint=90-snapd-config'])
         self._set(['bridges.br54.dhcp4=false', '--origin-hint=90-snapd-config'])
         self._set(['bridges.br54.interfaces=[eth0]', '--origin-hint=90-snapd-config'])
+        self.assertTrue(os.path.isfile(defaults))
+        with open(defaults, 'r') as f:
+            yml = yaml.safe_load(f)
+            self.assertEqual("networkd", yml['network']['renderer'])
         p = os.path.join(self.workdir.name, 'etc', 'netplan', '90-snapd-config.yaml')
         self.assertTrue(os.path.isfile(p))
         with open(p, 'r') as f:
@@ -132,6 +138,26 @@ class TestSet(unittest.TestCase):
             self.assertNotIn('dhcp6', yml['network']['bridges']['br54'])
             self.assertEqual(['eth0'], yml['network']['bridges']['br54']['interfaces'])
             self.assertIs(False, yml['network']['bridges']['br55']['dhcp4'])
+            self.assertIs(2, yml['network']['version'])
+            self.assertEqual("NetworkManager", yml['network']['renderer'])
+
+    def test_set_origin_hint_override_no_leak_renderer(self):
+        defaults = os.path.join(self.workdir.name, 'etc', 'netplan', '0-snapd-defaults.yaml')
+        with open(defaults, 'w') as f:
+            f.write('''network:
+  renderer: networkd
+  bridges: {br54: {dhcp4: true}}''')
+        self._set(['bridges.br54.dhcp4=false', '--origin-hint=90-snapd-config'])
+        self.assertTrue(os.path.isfile(defaults))
+        with open(defaults, 'r') as f:
+            yml = yaml.safe_load(f)
+            self.assertEqual("networkd", yml['network']['renderer'])
+        p = os.path.join(self.workdir.name, 'etc', 'netplan', '90-snapd-config.yaml')
+        self.assertTrue(os.path.isfile(p))
+        with open(p, 'r') as f:
+            yml = yaml.safe_load(f)
+            self.assertIs(False, yml['network']['bridges']['br54']['dhcp4'])
+            self.assertNotIn('renderer', yml['network'])
 
     def test_set_origin_hint_override_invalid_netdef_setting(self):
         defaults = os.path.join(self.workdir.name, 'etc', 'netplan', '0-snapd-defaults.yaml')
@@ -168,6 +194,7 @@ class TestSet(unittest.TestCase):
             yml = yaml.safe_load(f)
             self.assertIs(False, yml['network']['bridges']['br54']['dhcp4'])
             self.assertIs(True, yml['network']['bridges']['br55']['dhcp4'])
+            self.assertNotIn('renderer', yml['network'])
 
     def test_set_empty_origin_hint(self):
         with self.assertRaises(Exception) as context:
@@ -274,16 +301,18 @@ class TestSet(unittest.TestCase):
                     yaml.safe_load(f)['network']['ethernets']['ens3']['dhcp4'])
 
     def test_set_overwrite(self):
-        with open(self.path, 'w') as f:
+        p = os.path.join(self.workdir.name, 'etc', 'netplan', 'test.yaml')
+        with open(p, 'w') as f:
             f.write('''network:
+  renderer: networkd
   ethernets:
     ens3: {dhcp4: "no"}''')
         self._set(['ethernets.ens3.dhcp4=true'])
-        self.assertTrue(os.path.isfile(self.path))
-        with open(self.path, 'r') as f:
-            self.assertIs(
-                    True,
-                    yaml.safe_load(f)['network']['ethernets']['ens3']['dhcp4'])
+        self.assertTrue(os.path.isfile(p))
+        with open(p, 'r') as f:
+            yml = yaml.safe_load(f)
+            self.assertIs(True, yml['network']['ethernets']['ens3']['dhcp4'])
+            self.assertEqual('networkd', yml['network']['renderer'])
 
     def test_set_delete(self):
         with open(self.path, 'w') as f:
